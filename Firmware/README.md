# LowPowerArrayFirmware

This repository contains the STM32CubeIDE project files used on the LowPowerArray board.

## Theory of Operation

### Power
The LowPowerArray can be powered via USB or pin headers on J101.
The power source is selected by placement of a jumper on J101.
A servo-style connector can be plugged into J101.
Refer to the schematics in [Charlie-KiCad](https://github.com/UM-NCPA/Charlie-KiCad/tree/main/LowPowerArray_v2) for pin descriptions.

### Modes
There are two modes of operation: Manual and Automatic.
The mode is selected with a jumper on J201.

In Manual mode (jumper present) data acquisition is started and stopped using the pushbutton connected to J202.

In Automatic mode (jumper not present) data acquisition will begin automatically once power is applied and the GPS is locked.
If the button is pressed while in Automatic mode, the data acquisition will be stopped and the device will revert to Manual mode.

### Status
At startup, the device will wait for a GPS lock, unless ```GPS_WAIT_LOCK``` is defined as 0 (useful for lab testing).
When the GPS is locked, the LED will quickly illuminate several times, indicating that it is ready to start data acquisition.

While the data acquisition is running, the LED will illuminate every other second.

Status messages will be printed over the UART pins on J201, and also over USB via the virtual COM port.

### Programming
The STM32 microcontroller is programmed via SWD using the pins SWDIO, SWCLK, NRST on J201.
A Nucleo development board, or dedicated programmer, can be used to program the device.

### Microphone Connections
The 10-pin FFC connector, J1, is used to connect to a microphone board.

Alternatively, the BCLK, FSYNC, and DATA pins are available as pin headers on J201.

### SD Card Storage
Audio and GPS data are stored on the microSD card.
The card must be formatted as exFAT.

At startup, the device will create a new directory with the prefix ```filesXXXX```, where XXXX is a number: i.e. ```files0001```.

Audio and GPS files will be stored in the newly created directory, with file names ```audioXXXX.pcm``` and ```gpsXXXX.txt```.
Audio data is raw PCM format, with 8 channels and 32-bit word length.
GPS data is stored as plain text NMEA sentences, exactly as it is received from the GPS module.

GPS data can be tied to the audio data by matching the file numbers.
There is one pair of GPS messages for each second, where the first pair of GPS messages is tied to the first frame of audio in the audio file.

### GPS Module
The GPS module provides the PPS (pulse per second) and BCLK (bit clock) signals, as well as location and time via NMEA messages over UART.

Be sure to program the GPS module using the configuration file ```charlie-m8t-lowpower.txt```.

There is a battery connector, labeled BT101, which can provide backup power to the GPS.
The battery should be a 3v coin-cell or equivalent, and are commonly available as CMOS batteries.

Be sure to plug in the battery with the correct polarity (+ and - are marked on the v2 board).

If for some reason the GPS is not used, an auxiliary clock source can be used by populating a 12.288MHz crystal oscillator X501.
If this is used, select the clock source by placing R502 instead of R501.
Using the auxiliary clock source will require firmware changes to account for the missing PPS signal, and no GPS messages.
At time of writing this is not supported by the firmware.

For debugging purposes, when GPS lock is not required to start data acquisition, go to the file ```gps_mgr.h``` and change ```GPS_WAIT_LOCK``` to 0,
and re-program the device.
This will allow you to test the device in the lab, where GPS signals are not available.

## Programming Guide

### main.c
The file [main.c](https://github.com/UM-NCPA/LowPowerArrayFirmware/blob/main/Core/Src/main.c) mostly contains code generated by CubeIDE. This file simply initializes the peripherals, and calls the user_app_init and user_app_loop functions.
This file should not have to be changed.

### user_app.c
The file [user_app.c](https://github.com/UM-NCPA/LowPowerArrayFirmware/blob/main/Core/Src/user_app.c) contains the high-level runtime behavior of the device.
This includes the main endless while loop, the data acquisition loop, and button and PPS callback functions.

The endless while loop in user_app_loop implements the state diagram described below.

### aud_mgr.h
The file [aud_mgr.h](https://github.com/UM-NCPA/LowPowerArrayFirmware/blob/main/Core/Inc/aud_mgr.h) contains the audio-specific code.
This uses the SAI peripheral in DMA mode, so that audio data can be received 'in the background' while the CPU is working on other tasks.

The ```HAL_SAI_RxCpltCallback``` is called by the hardware when a buffer of new data is ready.
In this function, the DMA buffer pointer is changed to the next buffer in the ring buffer.
The ring buffer allows for multiple buffers to be stored before they are written to the SD card. 

If there is an SAI error, or ring buffer overflow, the data acquisition will be stopped and the PPS will be re-synchronized.

### sd_mgr.h
The file [sd_mgr.h](https://github.com/UM-NCPA/LowPowerArrayFirmware/blob/main/Core/Inc/sd_mgr.h) contains the sd card-specific code.
This code contains functions for starting new files, and writing to existing files.

### gps_mgr.h
The file [gps_mgr.h](https://github.com/UM-NCPA/LowPowerArrayFirmware/blob/main/Core/Inc/gps_mgr.h) contains the GPS-specific code.
GPS data is received over USART2 in DMA mode.

When the GPS messages have been received, the ```HAL_UARTEx_RxEventCallback``` function will be called by the hardware.
The received messages will be copied to local buffers, and the RX will be restarted to handle the next message.

### inline functions
Many of the functions implemented in the peripheral files are ```inline``` functions.
This is done for execution speed: basically instead of actually calling those functions,
the compiler will copy that code to where the function was called.

### DAQ State Diagram
This figure describes the various states that the device can be in, and the events that cause a state change.
The ```daq_stat``` variable declared in user_app.c is used to read and change state in the code.

![State Diagram](https://github.com/UM-NCPA/LowPowerArrayFirmware/blob/main/Docs/StateDiagram.png?raw=true)

## Future Work

### Magnetometer / Compass
The magnetometer added in v2 of the LowPowerArray board is not yet implemented by the firmware.
It is connected to i2c1 on pins PB8 and PB9. Ideally, the magnetometer data should be read in Interrupt mode (non-blocking).
Once the magnetometer data has been received and processed, the compass heading can be written to the GPS file, preferably in plain text.
Write the compass heading to the file once per second, same as the GPS data.
An easy way to do this would be to write it right after the GPS data is written.

### Directory / file naming
It would probably be better to name the files using the UTC date and time as received from the GPS.
This would require parsing each GPS message, and some more logic for dealing with the timing in creating the files.

### Control and monitoring over UART / USB
It might be possible to start and stop the data acquisition over UART or USB, though I haven't explored this in detail.
This would allow a remote computer, such as a raspberry pi, to control the data acquisition.
Additionally, a telemetry radio could be connected to the UART serial port for remote status monitoring and control.
